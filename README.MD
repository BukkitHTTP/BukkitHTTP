BukkitHTTP : Backend, Redefined.
==

简介
--
BukkitHTTP是一个类似于Bukkit的HTTP服务端。  
比起Spring等框架，BukkitHTTP更加轻量级，而且具有以下不可替代的优势：

1. 组件模块化。您可以在一个端口下运行多个而不是一个应用程序。
2. 路径路由。您可以在不修改模块源代码的情况下更改模块路由。
3. 可热重载。不需要重启服务端，您就可以安装新的模块或者卸载已有模块。
4. 跨平台。BukkitHTTP不依赖Native库，可以在任意支持Java的平台上运行。
5. 可加密。保护您的模块不被反编译。*

*：尽管我们理解并尊重闭源，但是我们不鼓励闭源。因此此项没有文档，也不提供答疑。  
这些优势以往被认为是只有php等语言才具有的。

同时，BukkitHTTP也是NanoHTTPd2的一个扩展，因此您可以使用NanoHTTPd2的所有功能的同时，只安装一份BukkitHTTP。

下载
--
烦请查看右侧Release。

安装
--
下载BukkitHTTP的最新版本，并运行。  
对！就是这么简单！

模块
--
每一个模块都是一个文件夹。  
这种文件夹应该被直接放在plugins目录下。

这个文件夹应该至少包含以下两个文件：

- plugin.properties
- xxx.jar

plugin.properties是模块的描述文件。
它由四个部分组成：

- jar : 指定模块jar的名称。例如：xxx.jar
- main : 指定在模块jar中，主类的路径。例如：com.example.Main
- name : 指定在模块管理时，模块显示的名称。例如：PluginName
- uri : 指定模块的路由。例如：/plus

一般而言，您可以修改除了main以外的任意字段。  
不过在修改jar字段时，不要忘记同时更改模块jar的文件名。

当然，一般而言，这个文件夹可能包含更多的文件（夹）；  
关于这些额外的文件（夹）作用，请与模块作者取得联系。

路由
--
在介绍这个功能前，先考虑一下这个操作：
> 假设有一个test.php提供聊天功能；我们把它放在chat文件夹下。  
> 然后，我们访问 http://127.0.0.1/chat/test.php 就可以访问聊天室了~

在这个例子里，如果我们把index.php换成一个模块，那么chat就是它的路由。  
对于一个模块，假如这个模块在/test路径下提供了一个服务，那么，  
如果它的路由是/router1，那么您就可以通过访问 http://127.0.0.1/router1/test 来访问这个服务；  
如果它的路由是/rou/ter2，那么您就可以通过访问 http://127.0.0.1/rou/ter2/test 来访问这个服务。

#### 路由冲突，优先，与落回

两个插件不能拥有相同的路由，否则，后加载的插件将加载失败。  
这种行为被叫做“路由冲突”。

对于每一个请求，BukkitHTTP都会尝试寻找与之匹配的最长路由。  
这种行为被叫做“路由优先”。  
假设有两个路由：

- /router1 【模块1】
- /router1/router2 【模块2】

对于请求 http://127.0.0.1/router1/test1 而言，它将被分配给模块1，分配后路径是/test1。  
对于请求 http://127.0.0.1/router1/router2/test2 而言，它将被分配给模块2，分配后路径是/test2。  
这是因为，第二个路由“更优先”。

当一个请求没有任何路由与之匹配，或者与之匹配的模块拒绝了这个请求，他将被落回。
> 需要注意的是，在上例中，如果 /router1/router2 拒绝了一个请求：
> 它将直接触发路由落回，而不是被送至 /router1 。

一个被落回的请求将再次被向所有插件问询是否处理。  
这个询问与路由无关。  
沿用上例，如果模块2拒绝了这个请求，那么模块1和其他所有的模块（含模块2）将收到落回问询。  
落回问询的路径将永远是 /router1/router2/test2。  
这种行为被叫做“路由落回”。

命令
--
命令是一个特殊的字符串：当您在控制台中输入命令并回车时，可以触发一定的行为。  
我们提供了几个内置命令，现列举如下：

#### help

当这个命令被输入时，服务器将显示所有被注册了的命令。

#### stop

当这个命令被输入时，服务器将逐个通知插件保存数据，然后退出。

#### load

当这个命令被输入时，您将被询问文件夹名称。  
BukkitHTTP将会在plugins目录下寻找这个文件夹，并尝试作为模块加载它。

#### unload

当这个命令被输入时，您将被询问模块名称（注意：不是文件夹名称）。
BukkitHTTP将会尝试卸载这个模块。

#### pl

当这个命令被输入时，服务器将显示所有被加载了的模块。

值得一提的是，系统命令也可以被模块反注册或者重写。  
所以，如果您觉得某个系统命令的行为十分奇怪，请优先怀疑它是不是被某个模块重写了。

开发
--
[模块开发者文档](DEV.MD)  
如果是向继续开发BukkitHTTP，请参考代码中的注释。  
这里就不额外提供文档了。

Pro版本说明
--
Pro版本并不是BukkitHTTP的付费版本！BukkitHTTP是公益项目！  
Pro版本的初衷是：如果您使用BukkitHTTP来做私有项目，您可能会希望保护自己的模块不被反编译。  
因此，我们提供了一个模块加固的功能。为了和普通版本区分，我们叫它“Pro”版。    
在Bukkit_Router中您可以看见，
> if (pr.containsKey("cipher")&& Main.VERSION.contains("Pro")) {

也就是说，如果您想要启用与Pro相关的功能只需要在版本号中包含“Pro”即可。  
但是！  
即使Pro版本虽然提供了模块加固的功能，这不意味着我们认可这种行为。  
因此，请不要在issue中提交相关问题。我们不会提供任何帮助。  
